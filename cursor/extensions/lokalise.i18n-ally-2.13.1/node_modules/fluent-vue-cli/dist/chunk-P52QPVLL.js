"use strict";Object.defineProperty(exports, "__esModule", {value: true});var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/vue.ts
var _compilersfc = require('@vue/compiler-sfc');
var _compilerdom = require('@vue/compiler-dom');

// src/ftl.ts
var _syntax = require('@fluent/syntax');
var serializer = new (0, _syntax.FluentSerializer)();
function getText(entry) {
  entry.comment = null;
  return serializer.serializeEntry(entry).substring(entry.id.name.length + 3).trimEnd();
}
function getMessages(content) {
  return _syntax.parse.call(void 0, content, { withSpans: false }).body.reduce((entries, entry) => {
    if (entry instanceof _syntax.Message) {
      entries[entry.id.name] = getText(entry);
    }
    return entries;
  }, {});
}
function merge(ftlSource, messages) {
  const currentResourse = _syntax.parse.call(void 0, ftlSource, { withSpans: true });
  for (const [key, value] of Object.entries(messages)) {
    const resourceString = `${key} = ${value}`;
    const resource = _syntax.parse.call(void 0, resourceString, { withSpans: false });
    let updated = false;
    for (const message of currentResourse.body) {
      if (message instanceof _syntax.Message && message.id.name === key) {
        updated = true;
        message.value = resource.body[0].value;
      }
    }
    if (!updated) {
      const newMessage = new (0, _syntax.Message)(new (0, _syntax.Identifier)(key), resource.body[0].value);
      currentResourse.body.push(newMessage);
    }
  }
  return _syntax.serialize.call(void 0, currentResourse, { withJunk: true });
}

// src/vue.ts
function getMessages2(source) {
  const descriptor = getDescriptor(source);
  descriptor.customBlocks.sort((a, b) => {
    return a.loc.start.offset - b.loc.start.offset;
  });
  return extractFromCustomBlocks(descriptor.customBlocks);
}
function merge2(source, locale, messages) {
  const parseResult = getDescriptor(source);
  let fluentBlock = parseResult.customBlocks.find((block) => block.type === "fluent" && block.attrs.locale === locale);
  if (fluentBlock != null) {
    const newBlockContent = merge(fluentBlock.content, messages);
    fluentBlock.content = newBlockContent;
  } else {
    fluentBlock = {
      type: "fluent",
      attrs: {
        locale
      },
      content: merge("", messages)
    };
  }
  const blocks = getBlocks(parseResult);
  return buildContent(fluentBlock, parseResult.source, blocks);
}
var decodeRE = /&(gt|lt|amp|apos|quot);/g;
var decodeMap = {
  gt: ">",
  lt: "<",
  amp: "&",
  apos: "'",
  quot: '"'
};
function getDescriptor(source) {
  return _compilersfc.parse.call(void 0, source, {
    sourceMap: false,
    ignoreEmpty: false,
    pad: false,
    compiler: {
      parse(template, options) {
        return _compilerdom.parse.call(void 0, template, __spreadProps(__spreadValues({}, options), {
          decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1])
        }));
      },
      compile: _compilerdom.compile
    }
  }).descriptor;
}
function extractFromCustomBlocks(blocks) {
  return blocks.map((block) => {
    if (block.type !== "fluent") {
      return void 0;
    }
    const locale = block.attrs.locale;
    if (locale == null || typeof locale !== "string") {
      throw new Error("fluent custom block does not have locale specified");
    }
    return {
      locale,
      messages: getMessages(block.content),
      source: block.content.trimStart()
    };
  }).filter(Boolean);
}
function getBlocks(descriptor) {
  const { template, script, styles, customBlocks } = descriptor;
  const blocks = [...styles, ...customBlocks];
  template != null && blocks.push(template);
  script != null && blocks.push(script);
  blocks.sort((a, b) => {
    return a.loc.start.offset - b.loc.start.offset;
  });
  return blocks;
}
function buildContent(blockToAdd, raw, blocks) {
  var _a;
  const EOL = (_a = /\r?\n|\r/g.exec(raw)) == null ? void 0 : _a[0];
  if (EOL == null) {
    return raw;
  }
  let offset = 0;
  let inserted = false;
  let contents = [];
  let fluentOffset = -1;
  contents = blocks.reduce((contents2, block, i) => {
    if (block.type === "fluent" && block.attrs.locale === blockToAdd.attrs.locale) {
      contents2 = contents2.concat(raw.slice(offset, block.loc.start.offset));
      contents2 = contents2.concat(`${EOL}${blockToAdd.content}`);
      offset = block.loc.end.offset;
      inserted = true;
    } else {
      contents2 = contents2.concat(raw.slice(offset, block.loc.end.offset));
      offset = block.loc.end.offset;
      if (block.type === "fluent") {
        fluentOffset = contents2.join("").length + "</fluent>".length + EOL.length;
      }
    }
    return contents2;
  }, contents);
  contents = contents.concat(raw.slice(offset, raw.length));
  let source = contents.join("");
  if (!inserted) {
    const content = `${EOL}<fluent locale="${blockToAdd.attrs.locale}">${EOL}${blockToAdd.content}</fluent>${EOL}`;
    if (fluentOffset !== -1) {
      source = source.slice(0, fluentOffset) + content + source.slice(fluentOffset);
    } else {
      source = source + content;
    }
  }
  return source;
}






exports.getMessages = getMessages; exports.merge = merge; exports.getMessages2 = getMessages2; exports.merge2 = merge2;
